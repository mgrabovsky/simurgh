~~~ Punctuation

> whiteSpace :: Parser ()
    Parse any white space, i.e. any number of `space` or comments.
> parens, brackets, braces, angles :: Parser a -> Parser a
    Parse a lexeme enclosed in parentheses `()`, brackets `[]`, braces `{}`, or
    angle brackets `<>`.
> colon, comma, semi, dot :: Parser String
    Parse a colon, comma, semicolon, or dot and skip any trailing white space.

~~~ Lexemes

> symbol :: String -> Parser String
    Parse a string and skip trailing white space.
> lexeme :: Parser a -> Parser a
    `lexeme p` first applies `p` and then the `whiteSpace` parser. This ensures that
    the next parser starts at a point without white space. Every lexical token
    (lexeme) is defined this way.
> commaSep, semiSep :: Parser a -> Parser [a]
    Parse zero or more occurences of a lexeme separated by a comma/semicolon.
> commaSep1, semiSep1 :: Parser a -> Parser [a]
    Parse _one_ or more occurences of a lexeme separated by a comma/semicolon.

~~~ Predefined lexemes

> identifier, operator :: Parser String
    Parse a legal identifier/operator. Fail on reserved identifiers/operators.
> reserved, reservedOp :: Parser String
    Parse a reserved identifier/operator which is not a prefix of a non-reserved
    identifier/operator.
> charLiteral :: Parser Char
> stringLiteral :: Parser String
    Parse a character or string literal. This parser deals correctly with esacpe
    sequences and gaps.
> natural :: Parser Integer
> integer :: Parser Integer
> float :: Parser Double
    Parse a natural number, an integer or a floating-point value according to the
    rules specified in the Haskell report.
> naturalOrFloat :: Parser (Integer + Double)
    Parse either an integer or a float.
> decimal, hexadecimal, octal :: Parser Integer
    Parse a natural number in decimal, hexadecimal (prefixed with `0x` or `0X`), or
    octal (prefixed with `0o` or `0O`) base.

~~~ Combinators

> choice :: [Parser a] -> Parser a
    Try to apply the parser in sequence until the first success.
> count :: Int -> Parser a -> Parser [a]
    `count n p` parses exactly `n > 0` occurrences of `p`.
> between :: Parser open -> Parser close -> Parser a -> Parser a
    TODO
> option :: a -> Parser a -> Parser a
> optionMaybe :: Parser a -> Parser (Maybe a)
    Try to apply the parser and return a default value/Nothing on failure.
> optional :: Parser a -> Parser ()
    `optional p` either parses exactly `p` or nothing. It only fails if `p` fails
    after consuming input.
> skipMany1 :: Parser a -> Parser ()
> many1 :: Parser a -> Parser [a]
    Apply a parser _one_ or more times and ignore/collect the results.

> sepBy, sepBy1 :: Parser a -> Parser sep -> Parser [a]
    TODO
> endBy, endBy1 :: Parser a -> Parser sep -> Parser [a]
    TODO
> sepEndBy, sepEndBy1 :: Parser a -> Parser sep -> Parser [a]
    TODO
> chainl, chainr :: Parser a -> Parser (a -> a -> a) -> a -> Parser a
> chainl1, chainr1 :: Parser a -> Parser (a -> a -> a) -> Parser a
    TODO

> eof :: Parser ()
    Parse end of input.

> notFollowedBy :: Parser a -> Parser ()
    TODO
> manyTill :: Parser a -> Parser end -> Parser [a]
    `manyTill p end` applies the parser `p` until `end` succeeds, collecting the
    results.
> lookAhead :: Parser a -> Parser a
    Parse without consuming any input. Fail if the inner parser fails with consumed
    input.

